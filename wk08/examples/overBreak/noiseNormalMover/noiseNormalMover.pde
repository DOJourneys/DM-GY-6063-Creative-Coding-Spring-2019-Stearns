//////////////////////////////////////////////////////////////////////////////
// noiseNormalMover
//
// a sketch that uses the noise() function to create a non-uniform "force field"
// uses PVectors to calculate a normal vector based on an image's brightnes
// uses those normal vectors to push Mover objects to the local minim brightness
// 
// mouseY mapped to z-axis of the noise()


// adjusts the noise scale
float scale=.125;

// image generated by perlin noise
PImage noise;

// used to make a smaller version of the noise image to speed things up
int div = 10;

// and array of 1000 movers
Mover[] movers = new Mover[1000];

//////////////////////////////////////////////////////////////////////////////
// setup

void setup() {
  size(500, 500);

  generateForceField();

  // create instances of our Movers
  for (int i = 0; i < movers.length; i++) {
    movers[i] = new Mover();
  }
  
}

//////////////////////////////////////////////////////////////////////////////
// draw

void draw() {
  
  generateForceField();

  image(noise, 0, 0);

  updateMovers();
  
}

//////////////////////////////////////////////////////////////////////////////
// generateForceField

void generateForceField() {
  noise = drawNoise(width/div, height/div);
  noise.resize(width, height);
}

//////////////////////////////////////////////////////////////////////////////
// drawNoise

PImage drawNoise(int _w, int _h) {
  PImage image = createImage(_w, _h, RGB);
  noiseDetail(3);
  image.loadPixels();
  for ( int y = 0; y < image.height; y++ ) {
    for ( int x = 0; x < image.width; x++ ) {
      // noise() generates a 0-1 value
      // map() scales to 0-255
      // color() converts to greyscale value
      image.pixels[ y * image.width + x ] = color( map( noise( x * scale, y * scale, scale * mouseY ), 0, 1, 0, 255 ) );
    }
  }
  image.updatePixels();
  return image;
}

//////////////////////////////////////////////////////////////////////////////
// updateMovers

void updateMovers() {
  for (int i = 0; i < movers.length; i++) {
    PVector force = calculateNormal( noise, movers[i].position );
    movers[i].applyForce( force );
    movers[i].update();
    movers[i].render();
    stroke(255); // velocity is cyan
    showVector( movers[i].velocity, movers[i].position);
    stroke(0); // force is yellow
    showVector( force, movers[i].position);
  }
}

//////////////////////////////////////////////////////////////////////////////
// calculateNormal
//
// returns only the x and y components of a 3D normal vector
// the normal vector represents the slope of a plane formed by
// three points in the x, y, and brightness (z) space of the image
// given points: vectors a, b, and c; vector ab = a - b and vector bc = b - c
// the normal vector of the plane containing all three points is ab X bc
// accuracy can be improved by sampling the same region at different
// angles and radii to get a number of different normal vectors, then average them

PVector calculateNormal(PImage _image, PVector _position) {
  // we need to store 3 points for calculate a normal vector
  PVector[] points = new PVector[3];
  // the distance from our position
  float r = 2;
  // sample the three points
  for (int i = 0; i < points.length; i++) {
    float x = r*cos((i+1)*2*PI/3)+_position.x;
    float y = r*sin((i+1)*2*PI/3)+_position.y;
    // make sure the points are in range of the image by wrapping the edges
    x = (x+_image.width)%_image.width;
    y = (y+_image.height)%_image.height;
    points[i] = new PVector(x, y, getBrightness(_image, x, y)/255);
  }
  // from the three points, calculate two vectors representing two edges of a triangle
  PVector a = PVector.sub(points[0], points[1]);
  PVector b = PVector.sub(points[1], points[2]);
  // the normal vector is the cross product of those two vectors
  PVector normal = a.cross(b);
  // we're interested only in the x and y components
  return new PVector(normal.x, normal.y);
}

//////////////////////////////////////////////////////////////////////////////
// getBrightness
// returns the brightness of a pixel in a PImage at a specified location

float getBrightness(PImage _image, float _x, float _y) {
  return brightness(_image.pixels[int(_y)*_image.width+int(_x)]);
}

//////////////////////////////////////////////////////////////////////////////
// showVector
// draws a line to show the vector
// needs the vector to draw and where to draw it

void showVector(PVector _vector, PVector _position) {
  PVector line = _vector.copy().setMag(5);
  pushMatrix();
  translate(_position.x, _position.y);
  line(0, 0, line.x, line.y);
  popMatrix();
}
